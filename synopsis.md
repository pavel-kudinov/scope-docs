# Синопсис
__Scope__ - это базовая специфическая структура, по имени которой назван фреймворк.

Для описания Scope структур, испольузется __JSON нотация__.

Условно, __Scope__ объединяет в себе свойства понятий:

- __Класс__
- __Множество__
- __Неймспейс__

# Класс

__Как "Класс"__, Scope реализует принцип ООП, позволяющий создавать множества объектов,
описывать их свойства и методы, а также включать статические свойства и методы

```js
// имя класса
Point: {
	// статическое JS/GPU свойство класса Point.simSpeed
	'float simSpeed': 0.1,
	
	// динамические GPU свойства экземпляров класса Point[i].pos
	pos: 'float2',
	vel: 'float2',
	
	// статический/динамический GPU метод класса
	'void method()': `
		// ...
	`,
	
	// статический JS метод класса
	method(){
		// данный класс
		this;
		
		// JS обращение к статическому свойству и методу класса
		this.simSpeed *= 1.01;
		this.method();
		
		// запуск 10 потоков GPU рантайма в контексте класса
		this(10,`
			// GPU side code "kernel"
			
			// в каждом потоке параллельно создаём по одному экземпляру класса
			Point.new {
				// обращение к динамическому свойству экземпляра класса
				.pos = {i,0};
				// вызов динамического метода экземпляра класса
				.method();
			};
			
			// вызов статического метода класса
			method();
			Point.method();
			
			// чтение статической переменной класса
			simSpeed;
			Point.simSpeed;
		`);
	},
}
```

# Множество

__Как "Множество"__, Scope является контейнером всех экземпляров своего класса:

На уровне кода, Scope одновременно является массивом, содержащим все созданные на данный момент
экземпляры класса:

```js
Point[i]      // обращение к экземпляру класса по индексу
Point.length  // количество экземпляров класса (длина массива)
```

вот примеры кода, работающие с множеством экземпляров класса:

```js
Point: {
	go(){
		// запускаем 1 поток GPU рантайма в контексте данного класса
		this(1,`
			// создаём три экземпляра класса
			Point.new();
			Point.new();
			Point.new();
			
			// обращаемся к экземплярам класса по индексу
			Point[0].pos = {0,0};
			Point[1].pos = {0,0};
			Point[2].pos = {0,0};
			
			// определяем общее количество экземпляров класса
			Point.length
			
			// последовательный перебор всех экземпляров класса
			Point {
				.pos += .vel;
			};
			
			// входим в контекст определённого экземпляра класса по индексу
			Point[2] {
				// выполняем действие в контексте
				.pos += .vel;
			};
		`);
		
		// параллельный цикл по всем экземплярам класса
		this.Point(`
			.pos += .vel * simSpeed;
		`);
		
		// последовательный цикл по всем экземплярам класса
		this(1,`
			for ( int i = 0; i < Point.length; i++ ) {
				Point[i] {
					.pos += .vel * simSpeed;
				};
			};
		`)
	},
};
```

# Неймспейс

__Как "Неймспейс"__, любой Scope может включать в себя описания других Scope

```js
// неймспейс Engine
Cosmos: {
	// неймспейс Cosmos.Node
	Node: {
		
	},
	// неймспейс Cosmos.Link
	Link: {
		
	},
};
```

важным аспектом работы со Scope является понимание механизмов областей видимостей неймспейсов
друг относительно друга:

__1. изнутри каждого неймспейса видны все неймспейсы, объявленные на одном уровне с данным неймспейсом
и выше по дереву__

доступ к вложенным неймспейсам, не видимым напрямую, осуществляется в точечной нотации,
через их предка, видимого относительно данного неймспейса

```js
{
	Cosmos: {
		Node: {
			go(){
				// из данной точки дерева область видимости выглядит так
				
				// видны напрямую
				this; // Node
				this.Link;
				this.Cosmos;
				this.Creature;
				
				// не видны напрямую
				this.Body;
				this.Mind;
				
				// но видны так ( через видимого предка Creature )
				this.Creature.Body;
				this.Crature.Mind;
				
				// несколько разных способов увидеть Node из данной точки дерева
				this;
				this.Node;
				this.Cosmos.Node;
				this.Root.Cosmos.Node;
			},
		},
		
		Link: {
			
		},
	},
	
	Creature: {
		Body: {
			Node: {
				
			},
			Link: {
				
			},
		},
		Mind: {
			Node: {
				
			},
			Link: {
				
			},
		},
	},
};
```

__2. изнутри неймспейса видны все переменные, объявленные в данном неймспейсе и выше по дереву__

```js
Engine: {
	'float simSpeed': 0.01,
	
	Ball: {
		'float collideForce': 0.01,
		
		go(){
			// видны напрямую
			this.collideForce;
			this.simSpeed;
			this.Link.resistForce;
			
			// не видна напрямую
			this.resistForce
			
			// ещё видны так:
			this.collideForce;
			this.Body.collideForce;
			this.Cosmos.Body.collideForce;
		},
	},
	
	Link: {
		'float resistForce': 0.01,
		
	},
}
```

__3. особенности доступа к неймспейсу, переменным и статическим методам из JS и GPU__

__JS код__ транслирует текущий неймспейс как __this__.

Мнемонически, правильно понимать __"this."__ в Scope коде, как __"здесь"__:

точка, относительно которой мы обращаемся к данному неймспейсу и к другим неймспейсам

```js
// данный неймспейс
this;
// другой неймспейс
this.Mind;
// неймспейс, вложенный в другой неймспейс
this.Mind.Neuron;

// вызов статического JS метода
this.method();
this.Mind.method();
this.Mind.Neuron.method();

// обращение к статическому свойству ( переменной )
this.someValue = 1;
this.Mind.someValue = 1;
this.Mind.Neuron.someValue = 1;
```

__GPU код__ транслирует текущий неймспейс как __Self__,
остальные неймспейсы, методы и свойства доступны напрямую без префикса __"this."__

```js
this(`
	// данный неймспейс
	Self;
	// другой неймспейс
	Mind;
	// неймспейс, вложенный в другой неймспейс
	Mind.Neuron;
	
	
	// вызов статического GPU метода
	
	// объявленного в данном или вышеописанном неймспейсе (в любом из предков)
	mehtod();
	// объявленного в другом неймспейсе
	Mind.method();
	// объявленного в неймспейсе, вложенном в другой неймспейс
	Mind.Neuron.method();
	
	
	// обращение к статическому свойству (переменной)
	// (с GPU, на данный момент, переменные видны только для чтения)
	
	// объявленной в данном или вышеописанном неймспейсе (в любом из предков)
	someValue;
	// объявленной в другом неймспейсе
	Namespace2.someValue;
	// объявленной в неймспейсе, вложенном в другой неймспейс
	Namespace2.SubNamespace.someValue;
`);
```

__4. область видимости GPU кода определяется неймспейсом, в контексте которого он запущен__

```js
{
	Namespace1: {
		'float property': 0,
		
		go(){
			// запуск в контексте Namespace1
			this(`
				// здесь видна
				property;
				
				// здесь не видна
				property2;
				
				// но видна так
				Namespace2.property2;
			`);
			
			// запуск в контексте Namespace2
			this.Namespace2(`
				// здесь видна
				property2;
				
				// здесь не видна
				property;
				
				// но видна так
				Namespace1.property
			`);
		},
	},
	Namespace2: {
		'float property2': 0,
	},
};
```

__5. перекрытие областей видимости__

Если во вложенном неймспейсе объявлен неймспейс, одноимённый вышележащему,
то он перекрывает собой область видимости вышележащего неймспейса, но к вышележащему
неймспейсу можно получить доступ через родителя.

Тоже самое справедливо и для переменных, а также для статических методов на GPU.

```js
Node: {
	'float property': 0,
	Body: {
		'float property': 0,
		Node: {
			
		},
		
		go(){
			// это переменная Body.property
			this.property;
			
			// это переменная Node.property
			this.Node.property;
		},
	},
};
```

__6. специальные псевдонимы неймспейсов__

На данный момент, существует два специальных псевдонима неймспейсов:

```js
this(`
	// корневой анонимный неймспейс
	Root;
	
	// текуший неймспейс, в контексте которого запущен GPU код
	Self;
`);
```
# GPU код

описание Scope симуляций представляет из себя JS код, перемежающийся
вставками __GPU кода__ (так называемыми __kernel'ами__):

__kernel__ код пишется как многострочный текст в обратных апострофах:

```js
Scope: {
	go(){
		// GPU код:
		// запуск параллельного GPU цикла по всем экземплярам данного класса
		this(`
			// итерируемый экземпляр Self[i]
			.;
			
			// свойство и метод итерируемого экземпляра
			.pos;
			.method();
		`);
	};
};
```

# Корневое дерево

Scope симуляция описывается как одно большое анонимное JSON-дерево, у которого есть корень и
иерархическая структура ветвей.

Доступ к корню этого дерева возможен по псевдониму __Root__.

```js
// Root
Scope({
	Creature: {
		Body: {
			Node: {
				
			},
			Link: {
				
			},
		},
		Mind: {
			Neuron: {
				
			},
			Synapse: {
				
			},
		},
	},
});
```

Таким образом, для описания симуляции мы определяем корневое дерево симуляции,
после чего вызываем корневой метод __.go()__

```js
Scope({
	Creature: {
		Body: {
			Node: {
				
			},
			Link: {
				
			},
		},
		Mind: {
			Neuron: {
				
			},
			Synapse: {
				
			},
		},
	},
	
	// корневой метод .go()
	// аналог функции main() в Си
	go(){
		// создаём один Creature на старте
		this(1,`
			Creature.new {
				
			};
		`);
	},
}).go();
```

# Модули

Любой Scope может быть практически мгновенно превращён в модуль

```js
Creature: {
	Body: {
		Node: {
			
		},
		Link: {
			
		},
	},
	Mind: {
		Neuron: {
			
		},
		Synapse: {
			
		},
	},
};
```

создаём файл __body.scope__

```js
run.void
body.scope
```

с содержимым

```js
module.exports = {
	Node: {
		
	},
	Link: {
		
	},
};
```

после этого заменяем секцию, описывающую ветку Body, на __use('body')__

```js
Creature: {
	Body: use('body'),
	Mind: {
		Neuron: {
			
		},
		Synapse: {
			
		},
	},
};
```

таким образом, Scope код может быть в любой момент легко разбит на модули.

__Модули, в свою очередь, также легко могут быть разбиты на подмодули:__

Для этого нужно создать папку, одноименную модулю,
поместить подмодули этого модуля в папку модуля,
а сам модуль поместить в эту папку под именем __index.scope__,
после этого, модуль можно подключать как __use('body')__

```js
body/index.scope
body/submodule.scope
run.void
```

Такая лёгкость важна для того, чтобы на начальном этапе комфортно описывать всю симуляцию
в качестве одного дерева, ограничиваясь единственным стартовым файлом,
и иметь возможность в любой момент вынести любую часть кода в отдельный модуль

Вообще, логика вложенных областей видимости и особенности поведения функции __use('module')__
преследуют именно возможность быстро и с наименьшими правками пластично менять иерархии неймспейсов,
что очень удобно в условиях, когда модульная структура симуляции много раз перестраивается
в процессе развития

# Реляционная схема классов

Важной особенностью __Scope__ является наличие двух параллельных систем взаимоотношений между классами:

- иерархическое дерево неймспейсов
- реляционная схема классов

Схема классов названа реляционной, потому что по дизайну копирует идею __ORM__:

Взаимоотношения между множествами экземпляров организуются в виде __реляционных таблиц__,
связь определяется схемой данных с помощью __'parent'__ и __['child']__ ссылок.

__Более того, технически, в памяти GPU множества экземпляров каждого класса образуют
упорядоченные таблицы данных в памяти, у каждого экземпляра есть свой id, а ссылки
являются int свойствами, интерпретируемыми как ссылки на объект с данным индексом в той таблице,
на которую ссылаются свойство.__

Сравним эти два примера:

```js
// просто иерархическое дерево неймспейсов
Creature: {
	Body: {
		Node: {
			
		},
		Link: {
			
		},
	},
}
```

```js
// реляционная схема классов
Creature: {
	// свойство экземпляра Creature - ссылка на экземпляр Body
	body: 'Body',
	Body: {
		// свойство экземпляра Body - множество ссылок на экземпляры Node
		nodes: ['Node'],
		Node: {
			// свойство экземпляра Node - множество ссылок на экземпляры Link
			links: ['Link'],
		},
		
		// свойство экземпляра Body - множество ссылок на экземпляры Link
		links: ['Link'],
		Link: {
			// свойства-ссылки на экземпляры класса Node
			from: 'Node',
			to  : 'Node',
		},
	},
}
```

Здесь описан __Creature__, у которого есть один __.body__, у которого есть множество __.nodes__ и __.links__,
причём __Node__ и __Link__ образуют граф, где __Node__ играет роль вершин, а __Link__ играет роль рёбер графа.
При этом каждый __Node__ может помнить список всех __.links__, с которыми он связан,
а __Body__ может помнить полные списки всех __.nodes__ и __.links__, которые в него входят.

Реляционная схема классов может быть избыточной, и часто бывает таковой,
так как системы ссылок носят прикладной алгоритмический характер.
Однако, любую реляционную схему классов можно описать не избыточно, в этом случае
обработать её алгоритмически всегда будет возможно, но не всегда - удобно и/или эффективно.

__Разница между описанием Scope, вложенным в другой Scope и наличием свойства экземпляра класса,
ссылающегося 'одиночно' или ['множественно'] на экземпляры другого Scope, заключается в том,
что иерархии вложенностей неймспейсов служат исключительно в целях образования пространств имён,
и никаким образом не определяют реляционные взаимоотношения между связанными множествами экземпляров различных классов.__

Более простой пример:

```js
Creature: {
	Body: {
		
	},
	
	go(){
		this(1,`
			// мы просто создаём экземпляр Creature,
			// но это НЕ приведёт к созданию экземпляра Body,
			// несмотря на то, что Body вложен в Creature
			
			Creature.new() {
				
			};
		`);
	},
},
```

```js
Creature: {
	Body: {
		
	},
	
	go(){
		this(1,`
			Creature.new() {
				// мы просто создаём экземпляр Body,
				// но он никак НЕ связан с только что созданным экземпляром Creature
				Body.new() {
					
				};
			};
		`);
	},
},
```

```js
Creature: {
	// определяем реляционную связь между Creature и Body
	// каждый экземпляр Creature ссылается на экземпляр Body свойством .body
	// при этом, на один и тот же Body может ссылаться как больше одного экземпляра Creature,
	// так и не ссылаться ни одного
	body: 'Body',
	Body: {
		
	},
	
	go(){
		this(1,`
			// создаём экземпляр Creature
			Creature.new() {
				// создаём экземпляр Body и кладём ссылку на этот экземпляр
				// в свойство .body только что созданного экземпляра Creature
				.body = Body.new() {
					// здесь можем определить свойства только что созданного .body
				};
			};
		`);
	},
},
```


# Контекст

- __контекст экземпляра__
- __контекстный неймспейс__
- __вход в контекст__
- __.нотация__
- __some нотация__
- __контекст метода экземпляра - экземпляр__

# Child списки

# Удаление экземпляров

По той причине, что экземпляры Scope хранятся в памяти GPU в виде упорядоченных таблиц,
при необходимости удалить один или несколько экземпляров из любого множества,
приходится дефрагментировать порядок элементов данного множества, чтобы заполнить пустоты.

В свою очередь, это приводит к обновлению индексов у всех сдвинувшихся элементов,
что вызывает необходимость обновить все входящие ссылки на все сдвинувшиеся элементы.

Иными словами, если сравнивать с SQL, то любая операция удаления из таблицы приводит к тому,
что многие записи данной таблицы меняют свой id, а все записи во всех таблицах,
ссылавшиеся на записи данной таблицы, должны обновить свои 'parent_id' / 'child_ids'

# Конструкторы и деструкторы

```js
Point[i]      // обращение к экземпляру класса
Point.length  // количество экземпляров класса (длина массива)

// добавление нового экземпляра класса.
// на данный момент может быть вызвано только в виде "входа в контекст" добавленного экземпляра класса
// внутри фигурных скобок "." - это this
// возвращать экземпляры классов как   some point = Point.new();   пока не умеет, но будет уметь
Point.new {
	.             // номер добавленного экземпляра класса
	Point[.]      // данный экземпляр класса, извлечённый по номеру
	.pos = {0,0}; // определение свойства 
};
```
# Наследование

# Планируемый к реализации функционал

- __@reverse ссылки__
- __сортировка и другие функции для child списков__
- __запись переменных из видеокарты__
- __полный доступ к данным из JS__
- __getter'ы и setter'ы__
- __развитие системы наследований__
- __временные списки данных__
- __сборщик мусора__
- __debug mode__
- __du -hs для Scope дерева__
- __META?__
- __документация по создаваемым симуляциям?__

# Проблемы, ожидающие решения

- невозможно создать дерево
- невозможно вызвать рекурсию
- .delete() иногда вызывает нарушения ссылочной целостности
- очень медленный .delete()
- много JS активности при запусках kernel'ов
- большой расход памяти служебными структурами данных
- двойной расход памяти служебными векторами remove

