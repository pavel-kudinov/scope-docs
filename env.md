#Окружение

Окружение Scope представляет собой __node.js__,
к которому подключен пропатченный нативный аддон __node-cuda__,
обеспечивающий возможность компилировать и запускать CUDA код из JavaScript

#use

в __Scope__ окружении повсеместно используется модуль __use__.

Этот модуль аналогичен по функциональности модулю __require__, но производит поиск
модулей, указанных без пути к ним, не в node_modules папках, а в корне каждой директории,
начиная от текущей и вверх вплоть до корня проекта, определяемого по наличию файла .project_root,
либо до корня файловой системы.

Такое поведение организовано для возможности кастомизировать поведение библиотек окружения,
копируя и модифицируя некоторые из них в папки отдельных симуляций:

Например, если необходимо быстро кастомизировать ренедеринг, можно скопировать render.scope
из корня репозитория в папку создаваемой симуляции, и конструкция { Render: use('render') } начнёт
подхватывать локальную копию библиотеки render, вместо глобальной. Код симуляции при этом менять не придётся.

Кроме того, use расширяет множество дефолтных расширений:

```js
*.js    // обычные js файлы
*.node  // скомпилированные (бинарные) нативные аддоны node.js
*.scope // модули, которые могут быть напрямую подключены в Scope дерево
```

#node-void

__node-void__ - это корневой модуль окружения, который производит несколько вещей:

- __1. node-void устанавливает специальный хук на use/require всех файлов с расширениями:__

```
*.scope
```

( внимание, *.js файлы НЕ обрабатываются )

хук препарсит подключаемый исходный код файла, обнаруживает все сочетания символов __`)__
и добавляет в каждый такой найденный фрагмент кода, случайное число

это необходимо для функционирования системы кеширования инлайновых вставок Scope кода:

```
this(`
	// scope kernel code
`);
```

преобразуется в

```
this(`
	// scope kernel code
`, 0.12834619521816211 );
```

при каждом запуске симуляции эти числа разные, но в пределах одного запуска повторные вполнения
одних и тех же участков кода позволяют системе кеширования __Scope__ идентифицировать
по этим числам точку кода запуска инлайнового kernel'а, обеспечивая однократную компиляцию
и последующее высокоэффективное многократное выполнение без повторных попыток компиляции

*.js файлы не обрабатываются, чтобы случайно не сломать лишними параметрами код какой-либо
внешней библиотеки, содержащий ту же последовательность символов __`)__

- __2. node-void организует WebGL контекст:__

изначально, void окружение было организовано не в node.js, а в node-webkit.
это позволяло использовать webgl и систему окон chromium для рендеринга и организации
пользовательского интерфейса.

запуск Scope в node-webkit окружении всё ещё возможен, но не может обеспечить максимальный FPS,
за счёт невозможности использовать CUDA VBO
(возможность использовать для вычислений и рендеринга одну и ту же память на GPU)

весной 2016 года Scope перешел на node.js + связку модулей, обеспечивающих webgl контекст
в отдельном окне, без DOM и других возможностей chromium:

при инициализации происходит последовательное подключение

```js
- node-cuda  // пропатченный аддон для работы с CUDA
- node-webgl // пропатченный аддон для организации webgl контекста
- node-glfw  // пропатченный аддон для создания glfw окна и обработки событий ресайза окна, клавиатуры и мыши
```

```js
// подключаем Scope
var Scope = use('scope');
// подключаем event loop
var loop  = use('loop');

// создаём корневой Scope
Scope({
	// подключаем render.scope (библиотека рендеринга)
	Render: use('render'),
	// подключаем random.scope (GPU-side генератор случайных чисел)
	Random: use('random'),
	
	// описываем Point
	Point: {
		// каждый Point имеет свои координаты
		pos: 'vbo float2',
		// цвет
		rgb: 'vbo float3',
		// вектор движения
		vel: 'float2',
		
		// go() будет рекурсивно вызван при запуске для каждого Scope
		go() {
			// Point регистрирует себя как облако частиц в библиотеке render.scope
			this.Render.pCloud([this, 'pos', 'rgb']);
		}
	},
	
	// корневой go() - это аналог функции main(), с него начинается выполение симуляции
	// (сначала происходит подключение и инициаизация всех подключенных и описанных sub Scope'ов )
	go() {
		// на этапе инициализации - создаём 100000 point'ов
		// запускаем параллельный for ( int i = 0; i < 100000; i++ )
		this(100000, `
			// создаём Point
			Point.new() {
				// задаём стартовые координаты
				.pos = ri2xy(1, i);
				// стартовый вектор движения
				.vel = rt2xy( Random.get(), Random.get() ) * 0.1;
				// цвет
				.rgb = t2rgb(i / (float)n);
			};
		`);
	},
	
	// animate фаза - описывает действия, обновляющие модель
	animate(){
		// изменяем координаты всех Point, прибавляя к ней вектор движения
		this.Point(` .pos += .vel; `);
	},

	// render  фаза - описывает действия, визуализирующие модель
	render(){
		this.Render.animate();
	},
},

// завершая описание корневого Scope, запускаем его, вызывая метод go()
// вызов .go() вызовет go()-инициализацию всех вложенных Scope,
// затем, в последнюю очередь, вызов .go() для корневого Scope
}).go();
```

#render.scope

__render.scope__ - модуль, обеспечивающий рендеринг:
- облаков частиц
- множеств линий
- множеств треугольников (полигонов)

для использования __render.scope__, нужно подключить библиотеку и зарегистрировать в ней, например, облако частиц:

```js
{
	Render: use('Render'),
	Point: {
		// на данный момент, все свойства, используемые при рендеринге,
		// должны иметь префикс "vbo " при описании типа, иначе будет ошибка
		pos: 'vbo float3',
		rgb: 'vbo float3',
		
		go(){
			// после выполнения этой команды, все существующие экземпляры Point будут отображаться при рендеринге
			// параметры:
			//     scope из которого брать координаты и цвета частиц,
			//     свойство, хранящее координаты частиц
			//     свойство, хранящее цвета частиц
			this.Render.pCloud([this, 'pos', 'rgb']);
		},
	},
};
```

Технически, __render.scope__ не является частью окружения, а является просто "шаблоном-обёрткой"
над __Three.js__

Для кастомизации ренедринга, нужно скопировать __render.scope__ в папку своей симуляции, после чего
напрямую редактировать код __render.scope__ с тем, чтобы кастомизировать шейдеры или расширить функционал библиотеки.
